// This file is auto-generated, don't edit it. Thanks.

using System;
using System.Collections.Generic;
using System.IO;

using Tea;

namespace AlibabaCloud.SDK.Adb20190315.Models
{
    public class DescribeSQLPlanResponseBody : TeaModel {
        /// <summary>
        /// Details about the execution of the SQL statement.
        /// </summary>
        [NameInMap("Detail")]
        [Validation(Required=false)]
        public DescribeSQLPlanResponseBodyDetail Detail { get; set; }
        public class DescribeSQLPlanResponseBodyDetail : TeaModel {
            /// <summary>
            /// The total CPU time consumed by all operators on multithreaded servers when the SQL statement is executed. Unit: milliseconds.
            /// </summary>
            [NameInMap("CPUTime")]
            [Validation(Required=false)]
            public long? CPUTime { get; set; }

            /// <summary>
            /// The IP address of the client that is used to execute the SQL statement.
            /// </summary>
            [NameInMap("ClientIP")]
            [Validation(Required=false)]
            public string ClientIP { get; set; }

            /// <summary>
            /// The name of the database on which the SQL statement is executed.
            /// </summary>
            [NameInMap("Database")]
            [Validation(Required=false)]
            public string Database { get; set; }

            /// <summary>
            /// The total number of rows generated by the SQL statement.
            /// </summary>
            [NameInMap("OutputRows")]
            [Validation(Required=false)]
            public long? OutputRows { get; set; }

            /// <summary>
            /// The total amount of data generated by the SQL statement. Unit: byte.
            /// </summary>
            [NameInMap("OutputSize")]
            [Validation(Required=false)]
            public long? OutputSize { get; set; }

            /// <summary>
            /// The maximum memory usage when the SQL statement is executed. Unit: byte.
            /// </summary>
            [NameInMap("PeakMemory")]
            [Validation(Required=false)]
            public long? PeakMemory { get; set; }

            /// <summary>
            /// The time when the execution plan of the SQL statement is generated. Unit: milliseconds.
            /// </summary>
            [NameInMap("PlanningTime")]
            [Validation(Required=false)]
            public long? PlanningTime { get; set; }

            /// <summary>
            /// The amount of time that the SQL statement is queued before it is executed. Unit: milliseconds.
            /// </summary>
            [NameInMap("QueuedTime")]
            [Validation(Required=false)]
            public long? QueuedTime { get; set; }

            /// <summary>
            /// The SQL statement.
            /// </summary>
            [NameInMap("SQL")]
            [Validation(Required=false)]
            public string SQL { get; set; }

            /// <summary>
            /// The beginning of the time range in which the SQL statement is executed. The time is in the UNIX timestamp format. Unit: milliseconds.
            /// </summary>
            [NameInMap("StartTime")]
            [Validation(Required=false)]
            public string StartTime { get; set; }

            /// <summary>
            /// The final execution state of the SQL statement. Valid values:
            /// 
            /// *   FINISHED
            /// *   FAILED
            /// </summary>
            [NameInMap("State")]
            [Validation(Required=false)]
            public string State { get; set; }

            /// <summary>
            /// The total number of stages in the SQL statement.
            /// </summary>
            [NameInMap("TotalStage")]
            [Validation(Required=false)]
            public long? TotalStage { get; set; }

            /// <summary>
            /// The total number of tasks in the SQL statement.
            /// </summary>
            [NameInMap("TotalTask")]
            [Validation(Required=false)]
            public long? TotalTask { get; set; }

            /// <summary>
            /// The time consumed to execute the SQL statement. Unit: milliseconds.
            /// </summary>
            [NameInMap("TotalTime")]
            [Validation(Required=false)]
            public long? TotalTime { get; set; }

            /// <summary>
            /// The name of the user who submitted the SQL statement.
            /// </summary>
            [NameInMap("User")]
            [Validation(Required=false)]
            public string User { get; set; }

        }

        /// <summary>
        /// The original details of the SQL statement.
        /// </summary>
        [NameInMap("OriginInfo")]
        [Validation(Required=false)]
        public string OriginInfo { get; set; }

        /// <summary>
        /// The ID of the request.
        /// </summary>
        [NameInMap("RequestId")]
        [Validation(Required=false)]
        public string RequestId { get; set; }

        /// <summary>
        /// Details about the plan stages.
        /// </summary>
        [NameInMap("StageList")]
        [Validation(Required=false)]
        public List<DescribeSQLPlanResponseBodyStageList> StageList { get; set; }
        public class DescribeSQLPlanResponseBodyStageList : TeaModel {
            /// <summary>
            /// The average `CPU Time` value on each compute node in the stage. Unit: milliseconds.
            /// </summary>
            [NameInMap("CPUTimeAvg")]
            [Validation(Required=false)]
            public long? CPUTimeAvg { get; set; }

            /// <summary>
            /// The maximum `CPU Time` value on each compute node in the stage. Unit: milliseconds.
            /// </summary>
            [NameInMap("CPUTimeMax")]
            [Validation(Required=false)]
            public long? CPUTimeMax { get; set; }

            /// <summary>
            /// The minimum `CPU Time` value on each compute node in the stage. Unit: milliseconds.
            /// </summary>
            [NameInMap("CPUTimeMin")]
            [Validation(Required=false)]
            public long? CPUTimeMin { get; set; }

            /// <summary>
            /// The average amount of input data on each compute node in the stage. Unit: byte.
            /// </summary>
            [NameInMap("InputSizeAvg")]
            [Validation(Required=false)]
            public long? InputSizeAvg { get; set; }

            /// <summary>
            /// The maximum amount of input data on each compute node in the stage. Unit: byte.
            /// </summary>
            [NameInMap("InputSizeMax")]
            [Validation(Required=false)]
            public long? InputSizeMax { get; set; }

            /// <summary>
            /// The minimum amount of input data on each compute node in the stage. Unit: byte.
            /// </summary>
            [NameInMap("InputSizeMin")]
            [Validation(Required=false)]
            public long? InputSizeMin { get; set; }

            /// <summary>
            /// The total CPU time consumed by all operators in the stage, which is equivalent to the total CPU time of the stage. You can use this parameter to determine which parts of the stage consume a large amount of computing resources. Unit: milliseconds.
            /// </summary>
            [NameInMap("OperatorCost")]
            [Validation(Required=false)]
            public long? OperatorCost { get; set; }

            /// <summary>
            /// The maximum memory usage when the SQL statement is executed. Unit: byte.
            /// </summary>
            [NameInMap("PeakMemory")]
            [Validation(Required=false)]
            public long? PeakMemory { get; set; }

            /// <summary>
            /// The average amount of data scanned by a scan operator on each storage node in the stage. Unit: byte.
            /// </summary>
            [NameInMap("ScanSizeAvg")]
            [Validation(Required=false)]
            public long? ScanSizeAvg { get; set; }

            /// <summary>
            /// The maximum amount of data scanned by a scan operator on each storage node in the stage. Unit: byte.
            /// </summary>
            [NameInMap("ScanSizeMax")]
            [Validation(Required=false)]
            public long? ScanSizeMax { get; set; }

            /// <summary>
            /// The minimum amount of data scanned by a scan operator on each storage node in the stage. Unit: byte.
            /// </summary>
            [NameInMap("ScanSizeMin")]
            [Validation(Required=false)]
            public long? ScanSizeMin { get; set; }

            /// <summary>
            /// The average amount of time consumed by a scan operator to read data on each storage node in the stage. Unit: milliseconds.
            /// </summary>
            [NameInMap("ScanTimeAvg")]
            [Validation(Required=false)]
            public long? ScanTimeAvg { get; set; }

            /// <summary>
            /// The maximum amount of time consumed by a scan operator to read data on each storage node in the stage. Unit: milliseconds.
            /// </summary>
            [NameInMap("ScanTimeMax")]
            [Validation(Required=false)]
            public long? ScanTimeMax { get; set; }

            /// <summary>
            /// The minimum amount of time consumed by a scan operator to read data on each storage node in the stage. Unit: milliseconds.
            /// </summary>
            [NameInMap("ScanTimeMin")]
            [Validation(Required=false)]
            public long? ScanTimeMin { get; set; }

            /// <summary>
            /// The ID of the stage.
            /// </summary>
            [NameInMap("StageId")]
            [Validation(Required=false)]
            public int? StageId { get; set; }

            /// <summary>
            /// The final execution state of the stage. Valid values:
            /// 
            /// *   FINISHED
            /// *   CANCELED
            /// *   ABORTED
            /// *   FAILED
            /// </summary>
            [NameInMap("State")]
            [Validation(Required=false)]
            public string State { get; set; }

        }

    }

}
